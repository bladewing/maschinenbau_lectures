\documentclass[xelatex,aspectratio=169]{beamer}
\input{preamble.tex}

% Title
\title{Algorithmen}
\author{Prof. Dr. Lukas Iffländer}
\institute{HTW Dresden}
\date{}
\usepackage{svg}

% Begin document
\begin{document}

% Title slide
\begin{frame}
  \titlepage
\end{frame}

\section{Allgemeines}

\begin{frame}{Was ist ein Algorithmus?}{Motivation}
  Täglich führen wir Dinge nach festen Handlungsvorschriften aus:
  \begin{itemize}
    \item Bedienungsanleitung (z.B. für Kaffeemaschine)
    \item Montageanleitungen (z.B. für IKEA-Möbel)
    \item Verhaltensvorschriften (z.B. für soziale Interaktionen)
    \item Rezepte (z.B. für Kuchen)
    \item Rechenvorschriften (z.B. für Addition)
  \end{itemize}

\end{frame}

\begin{frame}{Was ist ein Algorithmus?}
  \begin{definition}
    Ein Algorithmus ist eine Vorschrift zur Lösung einer Klasse von
    Problemen. Er besteht aus einer endlichen Folge von Schritten,
    mit der aus bekannten Eingangsdaten neue Ausgangsdaten eindeutig berechnet werden können.
  \end{definition}

  \begin{block}{Eigenschaften}
    \begin{itemize}
      \item Definition zeigt engen Zusammenhang zu mathematischen Funktionen (Eingabe, Ausgabe)
      \item Definition bindet den Algorithmus an eine Klasse von Problemen nicht an eine einzelne Aufgabe
    \end{itemize}
  \end{block}

  \begin{alertblock}{Problem}
    \begin{itemize}
      \item Die Definition eines Algorithmus enthält keine Forderungen an die praktische Ausführbarkeit des Algorithmus auf einer realen Maschine (z.B. Computer)
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}{Algorithmen als mathematische Funktionen}
  Ein Algorithmus kann als mathematische Funktion aufgefasst werden:
  \[ y = f \left(x\right) \mbox{ oder } f: D \rightarrow Z, x \rightarrow y \]
  \[ D: \mbox{Definitionsmenge}, Z: \mbox{Zielmenge} \]

  \begin{definition}
    In der Mathematik ist eine Funktion oder Abbildung eine Beziehung zwischen zwei Mengen, die jedem Element der einen Menge (Funktionsargument, unabhängige Variable, x-Wert) genau ein Element der anderen Menge (Funktionswert, abhängige Variable, y-Wert) zuordnet.
  \end{definition}
  \begin{block}{Interpretation}
    \begin{itemize}
      \item Element aus Mengen: Eingabe und Ausgabe
      \item Die Elemente können auch Mengen, Vektoren, Matrizen, etc. sein
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Berechenbarkeit}
  Somit wird einer Funktion ein Algorithmus zugeordnet.

  Es gibt aber Funktionen, denen kein Algorithmus zugeordnet werden kann. Diese Funktionen sind damit nicht berechenbar.

  \begin{definition}
    Eine Funktion $f$ heißt berechenbar, wenn es einen Algorithmus gibt, der für jedes Argument $x$ den Funktionswert $f\left(x\right)$ berechnet.
  \end{definition}

  \begin{exampleblock}{Beispiel}
    Ein einfaches Beispiel für eine berechenbare Funktion ist die Addition: $f\left(x\right) = x + 1$.
  \end{exampleblock}

  Weitere Beispiele folgen auf den nächsten Folien.

\end{frame}


\begin{frame}{Berechenbarkeit}{Beispiel: Sieb des Eratosthenes}
  \begin{block}{Problem}
    Finde alle Primzahlen bis zu einer gegebenen Zahl $n$.
  \end{block}

  \begin{block}{Algorithmus}
    \begin{enumerate}
      \item Erstelle eine Liste aller Zahlen von 2 bis $n$.
      \item Setze $p = 2$.
      \item Streiche alle Vielfachen von $p$ aus der Liste.
      \item Setze $p$ auf die nächste ungestrichene Zahl in der Liste.
      \item Wiederhole Schritte 3 und 4, bis $p^2 > n$.
      \item Die verbleibenden Zahlen in der Liste sind die Primzahlen.
    \end{enumerate}
  \end{block}

  \begin{exampleblock}{Zusatzübung}
    Implementierung als Python-Programm.
  \end{exampleblock}
\end{frame}

\begin{frame}{Berechenbarkeit}{Beispiel: Diskrete Funktion}
  Berechne die Funktionswerte der Funktion
  \[
    f\left(x+1\right) = 2 ^ {f\left(x\right)} \mbox{ mit } f\left(0\right) = 0
  \]
  für \( 6 \leq x \leq 12 \).

  \only<2->{\inputminted[firstline=8]{python}{src/algorithmus_funktion_weglaufend.py}}

  \only<3->{\begin{alertblock}{Problem}
      Die Werte der Funktion sind so groß, dass sie nicht mehr verarbeitet werden können.
    \end{alertblock}}

\end{frame}

\begin{frame}{Berechenbarkeit}{Ackermannfunktion I}

  \begin{definition}
    Die Ackermannfunktion ist eine Funktion, die für zwei natürliche Zahlen $m$ und $n$ definiert ist. Sie ist rekursiv definiert durch:
    \[
      A\left(m, n\right) = \begin{cases}
        n + 1                                   & \mbox{falls } m = 0                    \\
        A\left(m-1, 1\right)                    & \mbox{falls } m > 0 \mbox{ und } n = 0 \\
        A\left(m-1, A\left(m, n-1\right)\right) & \mbox{falls } m > 0 \mbox{ und } n > 0
      \end{cases}
    \]
  \end{definition}

\end{frame}
\begin{frame}{Berechenbarkeit}{Ackermannfunktion II}

  \inputminted[firstline=8,lastline=16]{python}{src/algorithmus_ackermann.py}

  \begin{alertblock}{Problem}
    %Die Ackermannfunktion wächst sehr schnell und ist für größere Werte von $m$ und $n$ nicht mehr berechenbar.

    \begin{itemize}
      \item $A\left(3, 2\right) = 29$
      \item $A\left(3, 3\right) = 61$
      \item $A\left(4, 3\right)$ ist nach fünf Minuten noch nicht berechnet
    \end{itemize}

  \end{alertblock}
\end{frame}

\begin{frame}{Berechenbarkeit}{Nicht berechenbare Funktion}
  \begin{block}{Problem}
    Es gibt Funktionen, die nicht berechenbar sind.
  \end{block}

  \begin{exampleblock}{Beispiel}
    \begin{itemize}
      \item \enquote{Berechne} alle reellen Zahlen zwischen 0 und 1.
      \item Es kann bewiesen werden, dass ein solcher Algorithmus nicht existiert.
    \end{itemize}
  \end{exampleblock}

  \begin{alertblock}{Problem}
    Es gibt keine allgemeine Methode, um zu entscheiden, ob eine Funktion berechenbar ist.
  \end{alertblock}

\end{frame}

\begin{frame}{Berechenbarkeit}{Schlussfolgerungen}
  \begin{itemize}
    \item Viele Funktionen sind berechenbar und praktisch anwendbar (z.~B. Sieb des Eratosthenes).
    \item Manche Funktionen sind unter realistischem Ressourcen- und Zeitaufwand nicht auf einem Rechner umsetzbar, obwohl sie prinzipiell berechenbar sind (z. B. die gezeigte diskrete Funktion und die Ackermannfunktion).
    \item Einige Funktionen sind prinzipiell nicht berechenbar (wie die Berechnung aller reellen Zahlen zwischen 0 und 1).
  \end{itemize}
  \Rightarrow Es ist zweckmäßig, an Algorithmen solche Forderungen zu stellen, dass sie auf realen Maschinen praktisch ausgeführt werden können.

\end{frame}

\begin{frame}{Charakteristische Eigenschaften von Algorithmen I}
  \begin{itemize}
    \item \textbf{Endlichkeit}

          Ein Algorithmus muss aus einer endlichen Anzahl von Lösungsschritten bestehen und nach Abarbeitung dieser endlich vielen Schritte nach einer endlichen Zeit das Ende erreichen.

    \item \textbf{Eindeutigkeit}

          Die einzelnen Schritte eines Algorithmus und ihre Aufeinanderfolge müssen eindeutig beschrieben sein.
    \item \textbf{Allgemeinheit}

          Ein Algorithmus darf nicht nur die Lösung einer speziellen Aufgabe (z.B. Lösung der Gleichung $x^2 + 2x + 1=0$) , sondern muss die Lösung einer Klasse von Problemen (z.B. die Lösung aller quadratischen Gleichungen $ax^2 + bx + c = 0$) beschreiben.
  \end{itemize}
\end{frame}

\begin{frame}{Charakteristische Eigenschaften von Algorithmen II}
  \begin{itemize}
    \item \textbf{Determiniertheit}

          Die mehrmalige Anwendung des Algorithmus mit denselben Eingangsdaten muss immer wieder dieselben Ausgangsdaten liefern.

          Hinweis: Es gibt auch nicht-deterministische Algorithmen.
    \item \textbf{Effizienz}

          Ein Algorithmus muss möglichst wenig Ressourcen einer Maschine, d. h. möglichst wenig Rechenzeit und möglichst wenig Speicher in Anspruch nehmen.
  \end{itemize}
\end{frame}

\section{Darstellung}

\begin{frame}{Darstellung von Algorithmen}{Natürliche Sprache}
  Zur Darstellung von Algorithmen sind Grundelemente notwendig.
  \begin{exampleblock}{Beispiel: Lösung einer quadratischen Gleichung}
    \[ a x^2 + b x + c = 0 \]
    nach der Mitternachtsformel:
    \[ x_{1,2} = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \]
  \end{exampleblock}

  Neben der Notation einzelner elementarer Aktionen/Anweisungen, wie z. B. \enquote{Gebe die Werte der Koeffizienten $a, b, c$ ein}, sind auch Strukturen notwendig, die die zeitliche Ablauffolge darstellen:
  \begin{enumerate}
    \item Gebe die Werte der Koeffizienten $a, b, c$ ein.
    \item Berechne die Diskriminante $d = b^2 - 4ac$.
  \end{enumerate}
  oder eine Entscheidung repräsentieren:
  \begin{itemize}
    \item Falls $d < 0$: \ldots
  \end{itemize}
\end{frame}

\begin{frame}{Darstellung von Algorithmen}{Liste in natürlicher Sprache}
  \vspace{-1em}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{enumerate}
        \item Gebe Werte der Koeffizienten $a,b,c$ ein
        \item Berechne $d = b*b - 4*a*c$
        \item Falls $d \geq 0$: setze fort mit Schritt 6
        \item Ausgabe: "Keine Lösung"
        \item Stop
        \item Berechne $x_1 = \frac{-b + \sqrt{d}}{2*a}$
        \item Berechne $x_2 = \frac{-b - \sqrt{d}}{2*a}$
        \item Falls $d > 0$: setze fort mit Schritt 11
        \item Ausgabe: "Eine Lösung: ",$x_1$
        \item Stop
        \item Ausgabe: "Zwei Lösungen: ",$x_1$, " und ", $x_2$
        \item Stop
      \end{enumerate}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{block}{enthaltene Strukturen}
        \begin{itemize}
          \item Sequenz, d.h. Abarbeitung in der Reihenfolge der Nummerierung
          \item Auswahl, d.h. Entscheidung zwischen verschiedenen Alternativen (Überspringen von Schritten)
        \end{itemize}
      \end{block}
      \begin{alertblock}{Achtung}
        In Python kann dies nicht direkt umgesetzt werden, da die Logik \enquote{setze fort mit Schritt x} nicht existiert. Python hat keine GOTO-Anweisung.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Darstellung von Algorithmen}{Formale Darstellung}
  Bei der Darstellung von Algorithmen liegt der Schwerpunkt vor allem auf der Darstellung der zeitlichen Ablauffolge, dem sogenannten Steuerfluss.

  \begin{block}{Theorem von Böhm und Jacopini (1966)}
    Jeder Algorithmus kann durch eine Kombination von Sequenz, Auswahl und Iteration dargestellt werden.
  \end{block}

  \includegraphics[width=\textwidth]{img/structured_program_patterns.png}
\end{frame}

\begin{frame}{Darstellung von Algorithmen}{Formale Darstellung -- Möglichkeiten}
  Es wurden zwei verschiedene Darstellungsformen entwickelt, die hauptsächlich in Gebrauch sind und auf grafische Symbole zurückgreifen:

  \begin{itemize}
    \item Früher Programmablaufplan (PAP) \rightarrow heute durch UML-Aktivitätsdiagramm ersetzt
    \item Struktogramm
  \end{itemize}

  Beide repräsentieren eine sogenannte Syntax, die die Ausdrucksformen der Beschreibung formal spezifiziert.

  Die Bedeutung der Darstellung wird als Semantik bezeichnet.
\end{frame}

\begin{frame}{Aktivitätsdiagramm und Struktogramm}
  \begin{columns}
    \begin{column}{.6\linewidth}
      \includegraphics[width=\textwidth]{fig/algorithmus_aktivitaetsdiagram.drawio.pdf}
    \end{column}
    \begin{column}{.3\linewidth}
      \includegraphics[width=\textwidth]{fig/algorithmus_struktogram.pdf}

    \end{column}
  \end{columns}
\end{frame}

\section{Grundkonstrukte}

\begin{frame}{Sequenz}

  \begin{columns}[t]
    \begin{column}{.3\linewidth}
      \begin{block}{Im Struktogramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[height=.7\textheight]{fig/algorithmus_sequenz_struktogram.pdf}
        \end{minipage}
      \end{block}
    \end{column}
    \begin{column}{.3\linewidth}
      \begin{block}{Im Aktivitätsdiagramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[height=.7\textheight]{fig/algorithmus_sequenz_aktivitaetsdiagram.drawio.pdf}
        \end{minipage}
      \end{block}

    \end{column}
    \begin{column}{.4\linewidth}
      \begin{block}{In Python}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \inputminted{python}{src/algorithmus_sequenz.py}
        \end{minipage}
      \end{block}

    \end{column}
  \end{columns}

\end{frame}


\begin{frame}{Einseitige Selektion}

  \begin{columns}[t]
    \begin{column}{.4\linewidth}
      \begin{block}{Im Struktogramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[width=\textwidth]{fig/algorithmus_einseitige_selektion_struktogram.pdf}
        \end{minipage}
      \end{block}
    \end{column}
    \begin{column}{.3\linewidth}
      \begin{block}{Im Aktivitätsdiagramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[width=\textwidth]{fig/algorithmus_einseitige_selektion_aktivitaetsdiagram.drawio.pdf}
        \end{minipage}
      \end{block}
    \end{column}
    \begin{column}{.3\linewidth}
      \begin{block}{In Python}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \inputminted{python}{src/algorithmus_einseitige_selektion.py}
        \end{minipage}
      \end{block}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}{Zweiseitige Selektion}

  \begin{columns}[t]
    \begin{column}{.4\linewidth}
      \begin{block}{Im Struktogramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[width=\textwidth]{fig/algorithmus_zweiseitige_selektion_struktogram.pdf}
        \end{minipage}
      \end{block}
    \end{column}
    \begin{column}{.3\linewidth}
      \begin{block}{Im Aktivitätsdiagramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[width=\textwidth]{fig/algorithmus_zweiseitige_selektion_aktivitaetsdiagram.drawio.pdf}
        \end{minipage}
      \end{block}

    \end{column}
    \begin{column}{.3\linewidth}
      \begin{block}{In Python}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \inputminted{python}{src/algorithmus_zweiseitige_selektion.py}
        \end{minipage}
      \end{block}

    \end{column}
  \end{columns}

\end{frame}

\begin{frame}{Mehrstufige Selektion}{Mit if, elif und else}
  Selektionen können mehr als nur eine Wahr-/Falsch-Entscheidung enthalten.

  \inputminted{python}{src/algorithmus_mehrstufige_selektion.py}

  Der \texttt{else}-Fall ist optional und kann weggelassen werden.
\end{frame}


\begin{frame}{Mehrstufige Selektion}{Mit match-case}
  Seit Python 3.10 gibt es das Schlüsselwort \texttt{match} für mehrstufige Selektionen.

  \inputminted{python}{src/algorithmus_mehrstufige_selektion_match.py}

\end{frame}


\begin{frame}{Zyklus}

  \begin{columns}[t]
    \begin{column}{.3\linewidth}
      \begin{block}{Im Struktogramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[width=\textwidth]{fig/algorithmus_zyklus_struktogram.pdf}
        \end{minipage}
      \end{block}
    \end{column}
    \begin{column}{.3\linewidth}
      \begin{block}{Im Aktivitätsdiagramm}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \centering
          \includegraphics[width=\textwidth]{fig/algorithmus_zyklus_aktivitaetsdiagram.drawio.pdf}
        \end{minipage}
      \end{block}

    \end{column}
    \begin{column}{.4\linewidth}
      \begin{block}{In Python}
        \begin{minipage}[c][.7\textheight][c]{\textwidth}
          \inputminted{python}{src/algorithmus_zyklus.py}
        \end{minipage}
      \end{block}

    \end{column}
  \end{columns}

\end{frame}

\begin{frame}{Zählzyklus}{Arten}
  Für alle Zahlen vom Startwert (einschließlich) bis zum Endwert (ausschließlich) in Schritten von 1:
  \inputminted{python}{src/algorithmus_zaehlzyklus_range.py}

  Für alle Zahlen vom Startwert (einschließlich) bis zum Endwert (ausschließlich) in Schritten von 1:
  \inputminted{python}{src/algorithmus_zaehlzyklus_while.py}

  Für alle Zahlen in der Liste:
  \inputminted{python}{src/algorithmus_zaehlzyklus_list.py}
\end{frame}

\begin{frame}{Python: Range}
  \inputminted{python}{src/algorithmus_zaehlzyklus_range.py}

  \inputminted{python}{src/algorithmus_zaehlzyklus_range_step.py}

  \begin{itemize}
    \item Alle ganzzahligen Werte von start bis end in Schritten von step, wobei der Endwert nicht erreicht wird.
    \item Wird step weggelassen, wird der Standardwert 1 verwendet.
    \item Negative steps sind möglich, wenn der Startwert größer als der Endwert ist.
  \end{itemize}
\end{frame}

\begin{frame}{Wie komm ich hier raus? continue und break}

  In Python können Sie die Anweisungen \texttt{continue} und \texttt{break} verwenden, um Schleifen zu steuern.
  \begin{itemize}
    \item \texttt{continue} überspringt den aktuellen Durchlauf und fährt mit dem nächsten Durchlauf fort.
    \item \texttt{break} beendet die Schleife vorzeitig.
  \end{itemize}

  \inputminted{python}{src/algorithmus_break_continue.py}
\end{frame}

\section{Unterprogramme}

\begin{frame}{Definition von Unterprogrammen (Funktionen)}

  \begin{block}{In Python}
    \inputminted{python}{src/algorithmus_unterprogramme.py}
  \end{block}
  \begin{itemize}
    \item Als Definition bezeichnet man das Programmieren des Unterprogramms.
    \item Dabei wird das Unterprogramm noch nicht ausgeführt. Die Ausführung wird durch Aufrufe an anderen Stellen im Programm ausgelöst.
    \item Alle Größen, die der Teilalgorithmus aus der Umgebung zur Abarbeitung benötigt, müssen in der Parameterliste angegeben werden.
    \item Ergebnisse können mittels \mintinline{python}|return| zurückgegeben werden.
    \item \mintinline{python}|return| veranlasst auch die Rückkehr aus dem Unterprogramm.
  \end{itemize}
\end{frame}

\begin{frame}{Paramater und Argumente}
  \begin{exampleblock}{Definition}
    \begin{itemize}
      \item Parameter sind die Variablen, die in der Funktionsdefinition angegeben werden.
      \item Argumente sind die Werte, die beim Aufruf der Funktion übergeben werden.
    \end{itemize}
  \end{exampleblock}
  \begin{block}{Grundform der Wertübergabe an Funktionen}
    Die Argumente werden entsprechend der Anzahl und Reihenfolge der einzelnen Parameter angegeben.
  \end{block}

  \begin{columns}[t]
    \begin{column}{.35\linewidth}
      \inputminted[lastline=4,escapeinside=??]{python}{src/algorithmus_parameter.py}
    \end{column}
    \begin{column}{.65\linewidth}
      \inputminted[firstline=7,escapeinside=??]{python}{src/algorithmus_parameter.py}
    \end{column}
  \end{columns}


  \begin{tikzpicture}[remember picture]
    \draw[overlay, ->, line width=5pt, color=red]
    ([yshift=.7\baselineskip]pic cs:mass) --
    ([yshift=5\baselineskip]pic cs:mass) --
    ([yshift=3\baselineskip,xshift=-0.3em]pic cs:m) --
    ([xshift=-.3em,yshift=.7\baselineskip]pic cs:m);
    \draw[overlay, ->, line width=5pt, color=blue]
    ([yshift=.7\baselineskip]pic cs:speed) --
    ([yshift=4.5\baselineskip]pic cs:speed) --
    ([yshift=2.5\baselineskip,xshift=-0.3em]pic cs:v) --
    ([xshift=-.3em,yshift=.7\baselineskip]pic cs:v);
  \end{tikzpicture}
\end{frame}

\begin{frame}{Unterprogramme -- Warum?}
  Wann sollte Code in ein Unterprogramm ausgelagert werden?
  \begin{itemize}
    \item wenn gleiche Codeabschnitte mehrfach in Programm vorkommen.

          Durch Unterprogrammen wird Coderedundanz (gleicher Code an mehreren Stellen) vermieden.
    \item wenn Teilprobleme von der Lösung des Gesamtproblems entkoppelt werden sollen. Es ergibt sich dann eine bessere Übersichtlichkeit und bessere Änderungsfreundlichkeit.
    \item wenn mehrere Programme (bzw. Skripte) gleiche Codeabschnitte benötigen.
  \end{itemize}

  \begin{exampleblock}{Beispiel}
    \texttt{ggT} und \texttt{kgV} sind Teillösungen für andere Probleme und deshalb für Unterprogramme prädestiniert.
  \end{exampleblock}

\end{frame}

\begin{frame}{Platzierung von Funktionen und aufrufendem Code}{Variante I: In einer gemeinsamen Datei}
  \vspace{-\baselineskip}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{itemize}
        \item Oben werden die Funktionen definiert, unten wird der Scriptcode eingefügt.

        \item Die Verarbeitung startet mit der ersten Anweisung, die nicht in einer Funktion steht.

        \item Theoretisch können die Funktionen an einer beliebigen Stelle im Code stehen. Die Konvention ist jedoch, dass die Funktionen immer am Anfang stehen.
      \end{itemize}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{listing}
        \small
        \caption{algorithmus\_partialsumme\_1.py}
        \inputminted{python}{src/algorithmus_partialsumme_1.py}
      \end{listing}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Platzierung von Funktionen und aufrufendem Code}{Variante II: Aufteilung auf mehrere Dateien}
  \begin{itemize}
    \item Das Python-Skript muss das Modul importieren, um die Funktionen nutzen zu können.
    \item Beim Funktionsaufruf muss der Modulname vorangestellt werden.
    \item Die Verarbeitung startet mit der Skriptdatei, die aufgerufen wird.
  \end{itemize}
  \vspace{-\baselineskip}
  \begin{columns}[t]
    \begin{column}{.5\linewidth}
      \begin{listing}
        \caption{algorithmus\_ps\_modul.py}
        \inputminted{python}{src/algorithmus_ps_modul.py}
      \end{listing}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{listing}
        \caption{algorithmus\_partialsumme\_2.py}
        \inputminted{python}{src/algorithmus_partialsumme_2.py}
      \end{listing}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Import von Modulen}
  Für den Import müssen sich die Moduldateien entweder
  \begin{itemize}
    \item im lokalen Verzeichnis oder
    \item im globalen Suchpfad des Python-Interpreters befinden.
  \end{itemize}

  Importierte Module können auch mit einem Alias versehen werden:

  \inputminted{python}{src/algorithmus_import_psm.py}
  \inputminted{python}{src/algorithmus_import_math.py}

  Unkonventionelle Aliase sind nicht empfehlenswert, da sie den Code unleserlich machen. Etabliert sind dagegen \texttt{np} für \texttt{numpy} und \texttt{pd} für \texttt{pandas}.
\end{frame}

\section{Felder und Listen}

\begin{frame}{Felder bzw. Python-Listen}
  \begin{block}{Definition: Felder (engl. Array)}
    Algorithmen arbeiten oft auf Feldvariablen, die \(n\) einzelne Variablen als Folge enthalten, z.~B. \( z_1, z_2, \ldots, z_n \).
  \end{block}

  \begin{block}{Konvention: Felder (engl. Array)}
    In Programmiersprachen beginnt die Indizierung meistens mit 0. Bei der Länge von \(n\) Elementen wird das letzte Element mit \(n-1\) indiziert: \( z_0 , z_1, \ldots, z_{n-1} \).
  \end{block}

  \begin{exampleblock}{Anwendung}
    \begin{itemize}
      \item Vektoren im mathematischen Sinn
      \item Zeitreihen, beispielsweise für tägliche Temperaturmessungen
      \item möglich auch für mehrelementige Wertangabe (z.B. Koordinaten)
    \end{itemize}
  \end{exampleblock}

\end{frame}

\begin{frame}{Darstellung von Feldern in Diagrammen}
  Bei der Darstellung von Feldern in Aktivitätsdiagrammen und Struktogrammen gibt es zwei Möglichkeiten, als mathematische Notation mit tiefergestellten Indizes oder wie im Programmcode in eckigen Klammern.

  \tiny\centering
  \includesvg[width=\textwidth,height=.6\textheight]{fig/algorithmus_indices.svg}
\end{frame}

\begin{frame}{Felder in Python}
  Felder in Python werden durch den Datentyp Liste (\texttt{list}) dargestellt. Bei anderen Programmiersprachen sind Felder und Listen unterschiedliche Datentypen.

  Geordnete Zuweisung von Werten in einer Liste:

  \inputminted[firstline=1, lastline=3]{python}{src/algorithmus_list.py}

  Zugriff auf Elemente durch Indexwert in eckigen Klammern:
  \inputminted[firstline=5, lastline=5]{python}{src/algorithmus_list.py}

  Die Länge einer Liste kann mit der Funktion \texttt{len()} ermittelt werden:
  \inputminted[firstline=7, lastline=7]{python}{src/algorithmus_list.py}
\end{frame}

\begin{frame}{Features von Python-Listen}
  Python Listen bieten eine Vielzahl nützlicher Funktionen zur Manipulation (nicht vollständig):
  \begin{tabularx}{\textwidth}{lXl}
    \toprule
    \textbf{Funktion}  & \textbf{Beschreibung}                                          & \textbf{Beispiel}          \\
    \midrule
    \texttt{append()}  & Fügt ein Element am Ende der Liste hinzu                       & \texttt{list.append(5)}    \\
    \texttt{clear()}   & Entfernt alle Elemente aus der Liste                           & \texttt{list.clear()}      \\
    \texttt{count()}   & Zählt die Vorkommen eines Elements in der Liste                & \texttt{list.count(5)}     \\
    \texttt{index()}   & Gibt den Index des ersten Vorkommens eines Elements zurück     & \texttt{list.index(5)}     \\
    \texttt{insert()}  & Fügt ein Element an einer bestimmten Position in die Liste ein & \texttt{list.insert(0, 5)} \\
    \texttt{sort()}    & Sortiert die Liste in aufsteigender Reihenfolge                & \texttt{list.sort()}       \\
    \texttt{remove()}  & Entfernt das erste Vorkommen eines Elements aus der Liste      & \texttt{list.remove(5)}    \\
    \texttt{reverse()} & Kehrt die Reihenfolge der Elemente in der Liste um             & \texttt{list.reverse()}    \\
    \bottomrule
  \end{tabularx}
\end{frame}
\begin{frame}{Features von Python-Listen}
  Weitere vordefinierte Funktionen für Listen sind:
  \begin{tabularx}{\textwidth}{lXl}
    \toprule
    \textbf{Funktion} & \textbf{Beschreibung}                              & \textbf{Beispiel}                                \\
    \midrule
    \texttt{len()}    & Gibt die Anzahl der Elemente in der Liste zurück.  & \texttt{len([1, 2, 3])} $\rightarrow$ \texttt{3} \\
    \texttt{max()}    & Gibt das größte Element in der Liste zurück.       & \texttt{max([1, 2, 3])} $\rightarrow$ \texttt{3} \\
    \texttt{min()}    & Gibt das kleinste Element in der Liste zurück.     & \texttt{min([1, 2, 3])} $\rightarrow$ \texttt{1} \\
    \texttt{sum()}    & Gibt die Summe aller Elemente in der Liste zurück. & \texttt{sum([1, 2, 3])} $\rightarrow$ \texttt{6} \\
    \bottomrule
  \end{tabularx}

  \begin{exampleblock}{Hinweis}
    In den Übungen werden wir viele dieser Funktionen einmal ohne die vordefinierten Funktionen implementieren.
    Dies dient dem Verständnis, der Übung und der Wertschätzung der Existenz dieser Funktionen.
  \end{exampleblock}
\end{frame}

\begin{frame}{Verwendung von Listen}
  Die Listen-Variablen können wie Objekte (werden später noch erklärt) verwendet werden und verhalten sich vergleichbar.

  \begin{exampleblock}{Beispiel}
    \inputminted[escapeinside=??]{python}{src/algorithmus_list_methods.py}

  \end{exampleblock}

  \begin{tikzpicture}[remember picture, overlay]
    \node[
      draw=red,
      thick,
      fill=white,
      text=black,
      rectangle,
      name=objektvariable
    ] at ([xshift=10cm, yshift=1.5cm]pic cs:object2) {Objektvariable};
    \draw[overlay, ->, line width=3pt, color=red]
    (objektvariable) -- ([yshift=1.5cm]pic cs:object2) -- (pic cs:object1);
    \draw[overlay, ->, line width=3pt, color=red]
    (objektvariable) -- ([yshift=1.5cm]pic cs:object2) -- ([yshift=.6\baselineskip]pic cs:object2);
    \node[
      draw=blue,
      thick,
      fill=white,
      text=black,
      rectangle,
      name=methode
    ] at ([xshift=10cm, yshift=.8cm]pic cs:object2) {Methode};
    \draw[overlay, ->, line width=3pt, color=blue]
    (methode) -- ([yshift=.8cm]pic cs:meth2) -- (pic cs:meth1);
    \draw[overlay, ->, line width=3pt, color=blue]
    (methode) -- ([yshift=.8cm]pic cs:meth2) -- ([yshift=.6\baselineskip]pic cs:meth2);
  \end{tikzpicture}
\end{frame}

\section{Beispiele}

\begin{frame}{Flächeninhalt eines Dreiecks}{Aufgabenstellung}

  Prüfen Sie die Seitenlängen eines Dreiecks und berechnen Sie anschließend den Flächeninhalt.

  Ein Dreieck mit den Seiten $a$, $b$ und $c$ hat einen Flächeninhalt
  \[
    A = \sqrt{s \cdot (s - a) \cdot (s - b) \cdot (s - c)} \mbox{ mit } s = \frac{a + b + c}{2}
  \]

  Vor der Berechnung ist zu prüfen, ob das Dreieck überhaupt existiert.
\end{frame}

\begin{frame}{Flächeninhalt eines Dreiecks}{Algorithmus}
  \begin{columns}
    \begin{column}{.32\textwidth}
      \includegraphics[height=.8\textheight]{fig/algorithmus_dreiecksflaeche.pdf}
    \end{column}
    \begin{column}{.68\textwidth}
      \small
      \only<2->{\inputminted{python}{src/algorithmus_dreiecksflaeche.py}}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Lösung einer quadratischen Gleichung}{Aufgabenstellung}

  Lösen Sie eine quadratische Gleichung
  \[
    ax^2 + bx + c = 0 \quad \text{mit } a \neq 0
  \]
  nach der Vorschrift
  \[
    x = \frac{-b \pm \sqrt{D}}{2a} \quad \text{mit } D = b^2 - 4ac
  \]

  Der Algorithmus muss verschiedene Fälle unterscheiden und die Berechnung selektiv unterschiedlich ausführen.

  Die Ausgabe muss angepasst werden, je nachdem, ob es eine oder zwei Lösungen gibt.
\end{frame}

\begin{frame}{Lösung einer quadratischen Gleichung}{Algorithmus}
  \centering\includegraphics[height=.7\textheight]{fig/algorithmus_quadratic_equation.pdf}
\end{frame}

\begin{frame}{Lösung einer quadratischen Gleichung}{Code}
  \inputminted{python}{src/algorithmus_quadratic_equation.py}
\end{frame}

\begin{frame}{Weitere Aufgaben}{Vorschau auf Praktika}
  \begin{itemize}
    \item Sie haben zwei Zahlen gegeben, prüfen Sie, ob eine der Zahlen die andere teilt.
    \item Prüfen Sie, ob ein gegebenes Jahr ein Schaltjahr ist.
    \item prüfen Sie, ob ein gegebenes Datum zwischen 1583 und 2100 gültig ist.
    \item Bestimmen Sie das Minimum einer Zeichenfolge \(a_1, a_2, \ldots, a_n\)
    \item Sortieren Sie eine Liste von Zahlen in aufsteigender Reihenfolge.
  \end{itemize}
\end{frame}

\section{Rekursion}

\begin{frame}{Rekursive Algorithmen}
  In der Mathematik sind viele Funktionen rekursiv definiert.
  \begin{block}{Rekursion}
    Der Begriff der Rekursion beinhaltet, dass zur Definition einer Funktion diese selbst wieder mit benutzt wird, allerdings mit
    anderen Argumentwerten. Eine rekursive Definition benötigt stets eine (nichtrekursive) Anfangs- bzw. Abbruchbedingung.
  \end{block}
  \begin{exampleblock}{Beispiel: Fakultät}
    rekursive Definition: \(fak(n) = n \cdot fak(n-1)\)

    Anfangsbedingung: \(fak(0) = 1\)

    Hinweis: ist in Python als \texttt{math.factorial} bereits implementiert
  \end{exampleblock}
\end{frame}

\begin{frame}{Rekursive Algorithmen}{Charakteristika}
  \begin{itemize}
    \item Rekursive Definitionen sind in der Regel kurz und übersichtlich.
    \item Die Grundstruktur des Algorithmus ist sofort erkennbar.
    \item Rekursive Definitionen lassen sich leicht mit rekursiven Prozeduren (Funktionen) implementieren.
    \item Implementierte rekursive Algorithmen sind häufig ineffizient (hoher Ressourcenverbrauch: Speicher und Rechenzeit).
    \item Bestimmte rekursive Algorithmen können in iterative Algorithmen umgeschrieben und effizienter implementiert werden.
    \item Endständige Rekursion (z.B. Fakultätsberechnung: \(fak(0) = 1; \, fak(n) = n \cdot fak(n-1)\)) ist ein Beispiel dafür.
  \end{itemize}
\end{frame}


\begin{frame}{Rekursive Algorithmen}{Charakteristika}
  \begin{block}{Schrittweises Auflösen}
    Auflösen des fak()-Ausdrucks rechtsseitig, solange Argument
    größer als  Null
    \begin{align*}
      fak(0) & =1                                                             \\
      fak(n) & = n \cdot fak(n-1)                                             \\
      fak(n) & = n \cdot   (n-1) \cdot fak( (n-1) -1)                         \\
      fak(n) & = n \cdot   (n-1) \cdot (n-2) \cdot fak( (n-2) -1)             \\
      fak(n) & = n \cdot   (n-1) \cdot (n-2) \cdot (n-3) \cdot fak( (n-3) -1) \\
      \ldots                                                                  \\
      fak(n) & = n \cdot   (n-1) \cdot (n-2) \cdot (n-3) \cdot \ldots \cdot 1
    \end{align*}
    Im Ideal steht (wie hier) eine iterative Logik da. Dies ist aber nicht immer der Fall und zahlreiche rekursive Algorithmen sind nicht ohne weiteres iterativ umschreibbar.
  \end{block}
\end{frame}


\begin{frame}{Rekursive Algorithmen}{Struktogramm}
  \centering
  \includegraphics[height=0.8\textheight]{fig/algorithmus_faculty_struktogram.pdf}
\end{frame}

\begin{frame}{Rekursive Algorithmen}{Fibonacci-Zahlen}
  \begin{columns}[onlytextwidth]
    \column{0.5\textwidth}
    Rekursiv definierte Zahlenfolge:
    \begin{align*}
      fib(0) & = 0                   \\
      fib(1) & = 1                   \\
      fib(n) & = fib(n-1) + fib(n-2)
    \end{align*}

    \column{0.5\textwidth}
    \includegraphics[width=\textwidth]{fig/algorithmus_fibonacci_struktogram.pdf}
  \end{columns}
\end{frame}

\begin{frame}{Fibonacci Baum}
  \centering
  \begin{tikzpicture}[
      level distance=1.5cm,
      level 1/.style={sibling distance=6cm},
      level 2/.style={sibling distance=3cm},
      level 3/.style={sibling distance=1.5cm}
    ]

    \node {fib(6)}
    child {node {fib(5)}
        child {node {fib(4)}
            child {node {fib(3)}
                child {node {fib(2)}}
                child {node {fib(1)}}
              }
            child {node {fib(2)}}
          }
        child {node {fib(3)}
            child {node {fib(2)}}
            child {node {fib(1)}}
          }
      }
    child {node {fib(4)}
        child {node {fib(3)}
            child {node {fib(2)}}
            child {node {fib(1)}}
          }
        child {node {fib(2)}}
      };

  \end{tikzpicture}
\end{frame}

\begin{frame}{Fibonacci Zahlen}{Bedeutung}
  \begin{columns}[t, onlytextwidth]
    \column{0.5\textwidth}
    \centering \textbf{Wachstumsprozesse}
    \includegraphics[width=\textwidth]{img/fibonacci_rabbit.png}
    \column{0.5\textwidth}
    \only<2->{
      \centering \textbf{Natürliche geometrische Formen}
      \includegraphics[width=\textwidth]{img/fibonacci_spiral.png}
    }
  \end{columns}
\end{frame}
% End document
\end{document}
